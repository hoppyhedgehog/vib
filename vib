#!/bin/bash
###################################################################
#LAST_MODIFIED: 2022-08-10T09:59:25
###################################################################
#USING [VIB] https://github.com/hoppyhedgehog/vib
###################################################################
# DOCUMENTATION/ LOCATION: https://github.com/hoppyhedgehog/vib
###################################################################
# *Note: Shell MUST be in BASH or KSH or ZSH
###################################################################
###################################################################
# -*- coding: utf-8 -*-
#
# The MIT License (MIT)
#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
#
###################################################################
#
VERSION=8.8
#
###################################################################
PS4='${LINENO}: '
###################################################################
SCRIPT=$(basename ${BASH_SOURCE[0]})
###################################################################
shopt -s expand_aliases
###################################################################
#
# VI Editor Backup Utility (VIB)
#
# Created By
###################################################################
AUTHOR="bpatridge@tintri.com"


###################################################################
# DEFAULT 'bin' LOCATION OF VIB [ /usr/local/bin]
#       However it may be changed to /opt or any other location
###################################################################
VIB_DEFAULT_LOCATION=/usr/local/bin
###################################################################





###################################################################
###################################################################
###################################################################
###################################################################
#
# CONFIGURABLE SETTINGS
#
###################################################################
###################################################################
###################################################################
###################################################################
#
#Specify the number of backup files to create
#
###################################################################
MAX=10


###################################################################
#
# If file to edit is larger than MAX_USER_SUPPLIED_FILE_SIZE
# then do not make a backup
###################################################################

MAX_USER_SUPPLIED_FILE_SIZE=5000000				# 5GB

###################################################################
# MAIN LOCATION OF VIB
# default is /usr/local/bin
###################################################################
VIB_BINARY=$VIB_DEFAULT_LOCATION/vib

###################################################################
# IF There is a need to log results, backupfiles/etc to a specific
# subdirectory, then specify it here
# otherwise, the default will be used:
#
# DEFAULT:
#               Default $SCRIPT
#                       example:
#                       Log directory = /var/log/$SCRIPT
#
# ALTERNATE EXAMPLE 1:
#       If you wish to log to /var/log/omg/vib
#       Then you would specify "omg/vib" as the 'root' $SCRIPT
#
# ALTERNATE EXAMPLE 2
#       If you wish to log to the default of /var/log/vib
#       Then you would specify "vib" as the 'root' $SCRIPT
###################################################################
#
#
# Specify the fully qualified path to the backup
# directory. 
#
# DEFAULT:		/opt/vib/backups
#
# *note1: Do not use a trailing slash
# *note2: Ensure the path is prefixed with a slas
# *note3: By default it is the current local directory
# and a .backup directory is created
#
###################################################################

BACKUP_DIRECTORY=/opt/vib/backups

###################################################################
# PROMPTS: Do not prompt to commit changes
# if CONFIRM_CHANGES = 0 (default) Prompt to save changes
# if CONFIRM_CHANGES = 1 accept changes immediately
###################################################################
CONFIRM_CHANGES=1

###################################################################
# PROMPTS: Do not prompt to create a new file
# if MAKE_NEW = 0 Prompt before creating file
# if MAKE_NEW = 1 (default) Do NOT Prompt.
###################################################################
MAKE_NEW=1

###################################################################
# Notify the user a backup file is created
# and the location of the backup file
#
# BACKUP_NOTIFICATION = 0 (default) Notify user
# BACKUP_NOTIFICATION = 1 DO NOT  Notify user
###################################################################
BACKUP_NOTIFICATION=0

###################################################################
# DIRECTORY TO EXCLUDE
###################################################################
EXCLUDE_DIRECTORIES=

###################################################################
#
# Specify whether to backup the file in the current
# or the default backup diurectory
#
# 0 creates backup in the specified backup directory
# using the new BACKUP_DIRECTORY (default)
#
# 1 creates backup in the current directory in a
#   directory called '.vib_backup'
#
#
###################################################################
USEDIR=0


###################################################################
# MAIN VIB LOG DIRECTORY FOR 
###################################################################
LOGDIR="/var/log/${SCRIPT}"

###################################################################
# LOG ALL Output
# The following enables additional logging
# 0 = no
# 1 = yes
###################################################################
LOGALL=1

###################################################################
#
# VIB LOG FILE
#
# Verify and setthe VIB LOG HISTORY FILE
#
###################################################################


LOGFILE="$LOGDIR/vib-history.$(date '+%Y-%m').log"


###################################################################
# TEMP DIRECTORY FOR VIB CACHE FILES
# DEFAULT:	/tmp/vib_cache
###################################################################
TMPDIR=/tmp/vib_cache


##################################################################
# PROMPT to commit changes
#
# 0 = yes
# 1 = no
#
###################################################################
PROMPT=0

###################################################################
#
# MAXIMUM NUMBER OF VIB LOG FILES
#
###################################################################
MAXLOGS=10

###################################################################
#
# MAXIMUM FILE SIZE OF VIB LOG FILES
#
# 30M = default
#
###################################################################
MAXLOGSIZE=30000000


###################################################################
#
# VIB SCRIPT COMMENT INSERTED AFTER LAST MODIFICATION DATE
#
###################################################################
ENABLE_VIB_COMMENT=1 			# 0 enable  1 disable
VIB_COMMENT='USING \[VIB\] https://github.com/hoppyhedgehog/vib'



###################################################################
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################
##   ENDS CONFIGURABLE VARIABLE SECTION
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################









###################################################################
# OBTAIN SCRIPT NAME
###################################################################
SCRIPT=$(basename ${BASH_SOURCE[0]})



###################################################################
# OBTAIN SYSTEM HOST NAME
###################################################################
HOSTNAME=$(hostname)



###################################################################
# CHECK REQUIRED SYSTEM PATHS
###################################################################

for binpath in "/bin" "/usr/bin" "/sbin" "/usr/sbin"; do
	if [ $(echo $PATH|fgrep -q "$binpath"; echo $?) != 0 ]; then
		export PATH=$PATH:$binpath
	fi
done

###################################################################
# CHECK HOST OPERATING SYSTEM TYPE
###################################################################

unameOut="$(uname -s)"
case "${unameOut}" in
    Linux*)     machine=Linux;;
    Darwin*)    machine=Mac;;
    CYGWIN*)    machine=Cygwin;;
    *)          machine="UNKNOWN:${unameOut}"
esac

###################################################################
# DETERMINE TYPE OF SED USED
###################################################################
	case $machine in
		Mac)
			if [ -f /usr/local/bin/sed ]; then
					SED=/usr/local/bin/sed
			elif [ -f /usr/local/sbin/sed ]; then
					SED=/usr/local/sbin/sed
			elif [ -f /usr/local/share/sed ]; then
					SED=/usr/local/share/sed
			elif [ -f /usr/bin/sed ]; then
					SED=/usr/bin/sed
					msed=1
			elif [ -f /bin/sed ]; then
					SED=/bin/sed
					msed=1
			else
				echo "ERROR: Unable to locate sed"
				exit 1
			fi
			;;
		*)
			if [ -f /usr/local/bin/sed ]; then
					SED=/usr/local/bin/sed
			elif [ -f /usr/local/sbin/sed ]; then
					SED=/usr/local/sbin/sed
			elif [ -f /usr/local/share/sed ]; then
					SED=/usr/local/share/sed
			elif [ -f /usr/bin/sed ]; then
					SED=/usr/bin/sed
			elif [ -f /sbin/sed ]; then
					SED=/sbin/sed
			elif [ -f /bin/sed ]; then
					SED=/bin/sed
			else
				echo"ERROR: Unable to locate sed"
				exit 1
			fi
			;;
	esac

###################################################################
# VERIFY THAT THE CURRENT PATH CONTAINS THE BASIC SYSTEM
# PATHS IN THE CURRENT $PATH VARIABLE
###################################################################
# Define required paths in array
###################################################################
system_paths_arr=( "/bin" "/sbin" "/usr/bin" "/usr/sbin" "/usr/local/bin" )
#
p=0
for i in "${!system_paths_arr[@]}"; do
    if [[ "$PATH" =~ (^|:)"${system_paths_arr[$i]}"(|/)(:|$) ]]; then
        ((p++))
    fi
done
# If the current path does not contain all of the system_paths_arr paths then export the current path
if [ $p -lt ${#system_paths_arr[@]} ]; then
        tp=
        for i in "${!system_paths_arr[@]}"; do
            if [ $i == 0 ]; then
                tp=${system_paths_arr[$i]}
            else
                tp=$tp:${system_paths_arr[$i]}
            fi
        done
        export PATH=$PATH:$tp
fi
###################################################################
# FUNCTION TO WRITE ECHO'D OUTPUT TO INCLUDE DATE/TIME
# TO TTY AND/OR LOGFILE
###################################################################
writelog()
{
        local LOGDATE=`date '+%Y-%m-%dT%H:%M:%S.%N'`
        local user=`echo $MYID |tr "[:upper:]" "[:lower:]"`
	local arg="$2"

	if [ -z "$2" ]; then
		echo "[$LOGDATE] : $1 "
	else
		case "$2" in
			0) echo "$1";;
			1) echo "[$LOGDATE] : $1"|tee -a $LOGFILE;;
			2|q) echo "[$LOGDATE] $HOSTNAME $SCRIPT:  $user : | $1" & >> "$LOGFILE" ;;
		esac
	fi
	if [  $LOGALL  == 1 ]; then
			 echo "[$LOGDATE] $HOSTNAME $SCRIPT:  $user : | $1"  >> "$LOGFILE" 2>&1
	fi
}
###################################################################
###################################################################
# function used to create directories
# this function creates some 'idiot proofing' so as not to create or remove
# important core system directories
###################################################################
f_md(){
	local arg="$1"
	local stop=0
	if [ -d $arg ]; then
	    return 0
	fi

	if [ -f "$arg" ]; then
	    stop=1
	fi
	arr_safety=( "/" "/bin" "/boot" "/corefiles" "/dev" "/etc" "/home" "/lib" "/lib64" "/lost+found" "/media" "/misc" "/mnt" "/net"  "/opt" "/proc" "/sbin" "/selinux"  "/sys" "/   tftpboot"  "/usr" "/var" "/usr/local/bin" "/usr/bin" "/usr/sbin" )

	for check in ${arr_safety[@]}; do
	    if [ $arg == $check ]; then
		stop=1
	    fi
	done

	if [ $stop == 0 ] && [ ! -d "$arg" ]; then
	    mkdir -p "$arg" >/dev/null 2>&1
	    if [ $? == 0 ]; then
		return 0
	    else
		stop=1
	    fi
	else
	    stop=1
	fi

	if [ $stop == 1 ]; then
		writelog "ERROR: Problem creating directory [$arg]" 0
		exit 1
	fi
}
###################################################################
# CREATE MAIN LOG DIRECTORIES FOR VIB
###################################################################

f_md $TMPDIR
f_md $LOGDIR 

###################################################################
# Function to 'stat' a file
#
# ON MAC OSX the 'stat' command is different than on Linux
#
# Therefore we need to verify it is the proper version
###################################################################
statfile() {
		local file="$1"
		local option="$2"
		if [ -z $option ]; then
			writelog "ERROR: Unable to parse option in function() statfile"
			exit 1
		else
			case $option in
				perm)  stat -c %a "$file";;		# obtain file permissions in OCTAL
				size)  stat -c %s "$file" ;;		# obtain the total size in byte
				epoch)  stat -c %Y "$file" ;;		# obtain date in EPOCH
				date)
					if [ $(stat -c %y "$file"  >/dev/null 2>&1; echo $?) != 0 ]; then
						 stat -f "%Sm" -t "%Y-%m-%dT%H:%M:%S"
					else
						stat -c %y "$file" |cut -d. -f1|sed 's/ /T/g'
					fi	
					;;
			esac
		fi
}
	
###################################################################
if [ $(statfile $LOGDIR perm) != "6777" ]; then
        chmod -R 6777 $LOGDIR  >/dev/null 2>&1
fi

###################################################################
if [  -f $VIB_BINARY ]; then
        found_vib=1
else
        if [ -L $VIB_BINARY ]; then
                found_vib=1
        fi
fi
if [ -z $found_vib ]; then
        writelog $LINE 0
        writelog "ERROR: Expected to find [vib] in the default location: ${VIB_BINARY}. " 0
        writelog "Please edit vib configuration. To reflect the correct location." 0
        writelog $LINE 0
        exit 1
fi
if [ ! -d $LOGDIR ]; then
        writelog "ERROR: Unable to create $LOGDIR." 0
        exit 1
fi
###################################################################
#
# Gather User ID
#
###################################################################
MYID=$(who am i |awk '{print $1}'|tr "[:upper:]" "[:lower:]")
if [ -z "$MYID" ]; then
	MYID=$(whoami |tr "[:upper:]" "[:lower:]")
fi
###################################################################
# STRIP BACKSLASH FROM BACKUP_DIRECTORY IF IT EXISTS
###################################################################
BACKUP_DIRECTORY=$(echo $BACKUP_DIRECTORY|sed 's:/*$::')

###################################################################
# VERIFY BACKUP_DIRECTORY EXISTS
###################################################################

f_md $BACKUP_DIRECTORY

###################################################################
#
# Name of the temporary backup file
#
# *note: It includes the DATE and TIME
#
###################################################################
DATETIME=$(date '+%Y%m%d-%H%M%S')
EXACT_TIME=$(date '+%Y%m%d-%H%M%S.%N')
TMPFILE=$TMPDIR/.vib_tempfile.$MYID.$EXACT_TIME
REAL_DATETIME=`date '+%Y-%m-%dT%H:%M:%S'`
YEARMONTH=$(date '+%Y%m')
###################################################################
#
# VIB LOG FILE
#
# Verify and setthe VIB LOG HISTORY FILE
#
###################################################################
if [ $(statfile $LOGDIR perm) != "6777" ]; then
        chmod -R 6777 $LOGDIR  >/dev/null 2>&1
fi

LOGFILE="$LOGDIR/vib-history.$YEARMONTH.log"


###################################################################
# MISC VARS
###################################################################
f_md "/var/tmp"
NOVIB=/var/tmp/.novib
NOT_NEWFILE=0					# variable to determine
						# if file is new or not
						# 0 = not newfile
						# 1 = newfile
###################################################################
NOTIME=/var/tmp/.vib.notime
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################







###################################################################
###################################################################
###################################################################
# END CONFIGURATION SECTION
# DO NOT EDIT BELOW HERE
###################################################################
###################################################################
###################################################################








###################################################################
# vib_cleanup function to remove temporary files
###################################################################
vib_cleanup() {
	for i in "$@"; do
		(rm -f "$i" >/dev/null 2>&1 )
	done

	if [ ${#@} == 0 ] || [ -f $TMPFILE ]; then
		rm -f $TMPFILE &>/dev/null
	fi
}





###################################################################
# DECLARING SOME VARIABLES USED
###################################################################
###################################################################
###################################################################
COMMENT_LINE="###################################################################"
# Set LINE for use in output
LINE="-------------------------------------------------------------------"
# 
#
no=0
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################
# If USEDIR is set to 1 and BACKUP_DIRECTORY is the default
# post an error.
###################################################################
if [ $USEDIR == 0 ] && [ "$BACKUP_DIRECTORY" = ".vib_backup" ]; then
	writelog "When you set USEDIR=0 you must also modify BACKUP_DIRECTORY variable" 0
	exit;
fi
###################################################################
###################################################################
#
#Current Working Directory
#
###################################################################
PWD=$(pwd)

###################################################################
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################
usage() {
echo $LINE
echo "[V][I] [B]ackup Wrapper"
echo "by $AUTHOR v$VERSION"
echo $LINE
echo "usage:   
  # vi [-b|-e|-d|-l|-n|-r|-t|-x|-u|-v]  <file>
	-b 	Create Version backup
		(if 'VERSION=' Variable is atop script)
	-e 	Enable VIB
	-d 	Disable VIB
	-l 	Enable add Last Modification Date (Default is Enabled)
	-n 	Disable all Last Modification prepending
	-r 	Uninstall-Reset the alias to default
	-t 	FORCE Enable add Last Modification Date to <file>
	   	*note: Default for any scripts
	-x 	Set permissions to 755
	-v 	Verbose (debug) output"
echo $LINE
echo "Directories Used"
echo "Logs:		$LOGDIR"
if [ $USEDIR == 0 ]; then
	echo "Backups:	$BACKUP_DIRECTORY"
else
	echo -e "Backups:	$BACKUP_DIRECTORY \t# Based on CURRENT Directory"
fi
echo "Temp Dir:	$TMPDIR"
echo $LINE

exit
}
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################
##       END README
###################################################################
###################################################################
###################################################################
###################################################################
###################################################################










###################################################################
###################################################################
###################################################################
###################################################################
# PERFORM ACTION IF THE USER PRESSES CTRL-C TO EXIT
###################################################################
###################################################################

trap '
  echo "* * * CTRL + C Trap Occured * * *"
  printf "Quit? [n] "
  read answer
  if [ -n "$answer" ]; then
   case "$answer" in
     y|Y)
         if [ -f "$TMPFILE" ]; then
          writelog "Cleaning up then exiting ..."  0
          vib_cleanup
          exit 0;
         fi
         ;;
      *)
         writelog "Returning ..." 0 
        ;;
    esac
  else
     writelog "Returning ..." 0
  fi
' 1 2

###################################################################
###################################################################
#------------------------------------------
# FUNCTION TO ROTATE LOGFILE
#------------------------------------------
rotatelogs()
{
	#  if LOGFILE exists ...
	if [ -f "$LOGFILE" ]; then
		LOGSIZE=`ls -al "${LOGFILE}" |awk '{print $5}'`

		# if LOGSIZE is greater than MAXLOGSIZE
		if [ $LOGSIZE -gt $MAXLOGSIZE ]; then
			writelog $LINE
			writelog "The $LOGFILE size is $LOGSIZE "
			writelog "which is greater than $MAXLOGSIZE"
			writelog $LINE
			printf "Rotating logs ..."
			# if MAXLOGS is greater than zero
			  while [ $MAXLOGS -gt 0 ]
			    do
			       i=`expr ${MAXLOGS} - 1`
			     if [ -f  "${LOGFILE}.${MAXLOGS}" ]; then
			       num=`expr ${MAXLOGS} + 1`
			       mv "${LOGFILE}.${MAXLOGS}" "${LOGFILE}.${num}"

			       if [ -f "${LOGFILE}.${MAXLOGSIZE}" ]; then 
				rm "${LOGFILE}.${MAXLOGSIZE}" > /dev/null 2>&1
			       fi
			     fi
			   printf "."

			   done
			   mv "${LOGFILE}" "${LOGFILE}.1" > /dev/null 2>&1
			   touch "$LOGFILE"
			 printf "\ndone\n"
		fi
	fi
}
###################################################################
# Create Alias 'VI_BINARY' for the VI Editor'
###################################################################
if [ -f /usr/bin/vim ]; then
        VI_BINARY=/usr/bin/vim
elif [ -f /usr/local/bin/vim ]; then
        VI_BINARY=/usr/local/bin/vim
elif [ -f /usr/local/bin/vi ]; then
        VI_BINARY=/usr/local/bin/vi
elif [ -f /usr/bin/vi ]; then
        VI_BINARY=/usr/bin/vi
elif [ -f /bin/vi ]; then
        VI_BINARY=/bin/vi
else
        echo "VI Editor not found .."
        exit;
fi

###################################################################
setvib() {
		if [ $(grep -q "alias vi=.*vib" $HOME/.bashrc; echo $?) != 0 ]; then
			$SED -i  "s:alias vi=.*$:alias vi=\"$VIB_BINARY\":g" $HOME/.bashrc
			source $HOME/.bashrc
		fi
}
###################################################################
check_date_change() {
	local lm=$(head -10  "$FILE_DIRECTORY/$FILE_NAME"|grep -c "LAST.*MODIFIED")
	local vc=$(head -10  "$FILE_DIRECTORY/$FILE_NAME"|grep -c "USING.*VIB")
	local dc=0
	
	if [ $dc == 1 ]; then
		date_check=1
	elif [ $dc -gt 1 ]; then
		date_check=2
	elif [ $dc == 0 ]; then
		date_check=3
	fi
}
###################################################################
validate_version() {
	local ver="$1"
	rx='^([0-9]+\.){0,2}(\*|[0-9]+)(\-.*){0,1}$'
	if [[ $ver =~ $rx ]]; then
		echo 0
	else
		echo 1
	fi
}
###################################################################
m_readlink() {
    [ "." = "${1}" ] && n=${PWD} || n=${1}; while nn=$( readlink -n "$n" ); do n=$nn; done; echo "$n"
}
###################################################################
read_filename() {
	
	if [ $machine != "Mac" ]; then
		f=$(readlink -f $1)
	else
		f=$(m_readlink $1)
	fi
	echo $f
}
###################################################################
read_dirpath () {
	
	if [ $machine != "Mac" ]; then
		f=$(readlink -f $1)
	else
		f=$(m_readlink $1)
	fi
	local dir=$(dirname "$f")
	if [ "$dir" == "." ]; then
		dir=$(pwd)
	fi
	echo $dir
}
###################################################################
###################################################################
###################################################################
# GATHERING USER SUPPLIED INPUT
###################################################################
###################################################################
###################################################################

shopt -s extglob
ARGUMENTS=("$@")				#ZERO ARG ARRAY
TOTAL_ARGUMENTS="${#ARGUMENTS[@]}"			
ca=0
arg_list=()
for (( i = 0; i < ${#ARGUMENTS[*]}; ++ i )); do
	arg=${ARGUMENTS[$i]}
		case "$arg" in
		      ('-?')
				usage
				exit 0;;
		      ("-b")     backup_version=1;;
		      ("-h")
				usage
				exit 0;;
		      ("-x")     make_executable=1
				arg_list+=("x");;
		      ("--ver"|"--version")     usage;;
		      ("-v")     set -x
				arg_list+=("v");;
		      ("-T")     devtest=1;              # HIDDEN OPTION ONLY TO TEST
				arg_list+=("T");;
		      ("-t")     forcedate=1
				arg_list+=("t");;
		      ("-l")
				echo $LINE
				echo "ENABLED ALL PREPENDING OF"
				echo "LAST MODIFICATION TIME"
				echo $LINE
				vib_cleanup $NOTIME
				exit
				;;
		      ("-e")  rm -f $NOVIB >/dev/null 2>&1
				echo $LINE
				echo "ENABLED VIB"
				echo "REMOVED FILE: $NOVIB"
				echo $LINE
				setvib
				exit;;
		      ("-d")  touch $NOVIB
				echo $LINE
				echo "DISABLED VIB"
				echo "CREATED FILE: $NOVIB"
				echo "To re-enable VIB: vib -S"
				echo $LINE
				exit;;
		      ("-n")  touch $NOTIME
				echo $LINE
				echo "DISABLED ALL PREPENDING OF"
				echo "LAST MODIFICATION TIME"
				echo $LINE
				exit;;
		      ("-r")
				$SED -i "s:alias vi=.*$:alias vi=\"/usr/bin/vim\":g" $HOME/.bashrc
				source $HOME/.bashrc;
				echo $LINE
				echo "Reset vi back using:"
				echo "   # alias vi=/usr/bin/vim' "
				echo $LINE
				unalias vi 2>/dev/null
				exit;;
			*)

				if [ -L "$arg" ]; then
					SOFT_LINK_FILE_NAME=$(basename "$arg")
					FILE_DIRECTORY=$(read_dirpath "$arg")
					TF=$(read_filename "$arg")
					FILE_NAME=$(basename $TF)
					SOFT_LINK=1
					((ca++))
				elif [ -f "$arg" ]; then
					FILE_NAME=$(basename "$arg")
					FILE_DIRECTORY=$(read_dirpath "$arg")
					((ca++))
				else
					if [ $(echo $arg|grep -q "/";echo $?) == 0 ]; then	
						FILE_NAME=$(basename "$arg")
						FILE_DIRECTORY=$(read_dirpath "$arg")
					else
						FILE_NAME=$arg
						FILE_DIRECTORY=$(read_dirpath "$arg")
					fi
				fi
				;;

			esac
		
done
#--------------------------------------------------------------
if [ ! -z $setvib ]; then
        if [ $(grep -q "alias vi=.*vib" $HOME/.bashrc; echo $?) != 0 ]; then
                $SED -i  "s:alias vi=.*$:alias vi=\"$VIB_BINARY\":g" $HOME/.bashrc
                source $HOME/.bashrc
        fi
fi


if [ -f $TMPFILE ]; then
        vib_cleanup
fi

if [ -z $1 ]; then
        usage
fi

if [ $USEDIR != 1 ] && [ $BACKUP_DIRECTORY == ".vib_backup" ]; then
        echo "ERROR: BACKUP_DIRECTORY cannot equal .vib_backup when USEDIR is set ..."
        exit;
fi
#--------------------------------------------------------------
if [ ! -z $devtest ]; then
        set -x
fi                
if [ ! -z $devtest ]; then
	echo "FILE_NAME=$FILE_NAME"
	echo "FILE_DIR=$FILE_DIRECTORY"
fi
if [ -z $FILE_NAME ]; then
	echo $LINE
	echo "ERROR: Unable to find File Name"
	exit 1
fi

if [ $ca -gt 1 ]; then
	echo "ERROR: You can only specify ONE File"
	usage
fi
#----
if [ "$FILE_DIRECTORY" == "/" ]; then
	FILE_DIRECTORY=
fi
#----
if [ -f  "$FILE_DIRECTORY/$FILE_NAME" ]; then
	ORIGINAL_USER_SUPPLIED_FILE_EPOCH=$(statfile "$FILE_DIRECTORY/$FILE_NAME" epoch)
	ORIGINAL_USER_SUPPLIED_FILE_SIZE=$(statfile "$FILE_DIRECTORY/$FILE_NAME" size)
else
	NOT_NEWFILE=1
fi
###################################################################
# Create backup directory
###################################################################
f_md $BACKUP_DIRECTORY
###################################################################
###################################################################
###################################################################
# if USEDIR is set to 1, then set the FILE_NAME
# to the INPUT variable and change the assign
# FULLINPUT (path+filename) to the INPUT variable
###################################################################

if [ $USEDIR == 1 ]; then
	BACKUP_DIRECTORY=$(pwd)/.vib_backup
fi


###################################################################
# if backup dir doesnot exist  create backup directory
###################################################################

BACKUP_DIRECTORY=${BACKUP_DIRECTORY}${FILE_DIRECTORY}
if [ ! -d "$BACKUP_DIRECTORY"  ] && [ -z $nobackup ]; then
	writelog $MYID "Created $BACKUP_DIRECTORY"
	mkdir -p "$BACKUP_DIRECTORY"  > /dev/null 2>&1
fi

###################################################################
# Function to append the date changed based on when it was modified
###################################################################
add_change_date(){
	if [ ! -z $msed ]; then
		msedvar="''"
	else
		msedvar=
	fi


	if [ -z $noinsert_header ]; then
		mod_date=$(statfile "$FILE_DIRECTORY/$FILE_NAME" date)
		#---------------------------------------------------------------------
		# If the file already contains last modified
		#---------------------------------------------------------------------
		check_date_change

			if [ $ENABLE_VIB_COMMENT == 0 ]; then
					LC="\#$VIB_COMMENT\n$COMMENT_LINE"
			else
					LC="$COMMENT_LINE"
			fi

		if [ $lastmod_line -gt  0 ]; then
			$SED -i $msedvar  "${lastmod_line}s|.*|\#LAST_MODIFIED: $mod_date|" "$FILE_DIRECTORY/$FILE_NAME"
			if [ $ENABLE_VIB_COMMENT == 0 ]; then
				if [ $comment_line -gt 0 ]; then
					$SED -i $msedvar  "${comment_line}s|.*|\#$VIB_COMMENT|" "$FILE_DIRECTORY/$FILE_NAME"
				else
					$SED -i $msedvar  "4s|^.*|\#$VIB_COMMENT|" "$FILE_DIRECTORY/$FILE_NAME"
				fi
			fi

			writelog "Updated -->  LAST_MODIFIED: $mod_date" 

		#---------------------------------------------------------------------
		# IF there is no last modify, forcedate is set and file is NOT a script
		# OR if there is no last modify, and file is NOT a script
		#---------------------------------------------------------------------
		elif [[  ( ( $lastmod_line == 0 ) && ( ! -z $forcedate ) && ( -z $script ) ) || ( ( $lastmod_line == 0 ) && ( -z $script) )  ]];  then
			$SED -i $msedvar "1i$COMMENT_LINE\n\#LAST_MODIFIED: $mod_date\n$LC" "$FILE_DIRECTORY/$FILE_NAME"
			writelog "Added atop file -->  LAST_MODIFIED: $mod_date" 

		#---------------------------------------------------------------------
		# IF there is no last modify, and file  IS A SCRIPT
		#---------------------------------------------------------------------
		elif [ $lastmod_line == 0 ] && [ ! -z $script ]; then
			$SED -i $msedvar "2i$COMMENT_LINE\n\#LAST_MODIFIED: $mod_date\n$LC" "$FILE_DIRECTORY/$FILE_NAME"
			writelog "Added atop file -->  LAST_MODIFIED: $mod_date" 
		else
			$SED -i $msedvar "${lastmod_line}i$COMMENT_LINE\n\#LAST_MODIFIED: $mod_date\n$LC" "$FILE_DIRECTORY/$FILE_NAME"
			writelog "Added atop file -->  LAST_MODIFIED: $mod_date" 
		fi

		#---------------------------------------------------------------------
		# IF there is no $COMMENT_LINE after the USING VIB Comment, then add one
		#---------------------------------------------------------------------
		if [ $($SED -n '/#USING \[VIB\]/{n;p}' "$FILE_DIRECTORY/$FILE_NAME" |grep -e '#############' -c) == 0 ]; then
			$SED -i $msedvar "/USING \[VIB\]/a $COMMENT_LINE/" "$FILE_DIRECTORY/$FILE_NAME"
		fi
	fi

}
###################################################################
# checking to see if file is a script, and if so, then add file modification date
###################################################################
check_lastmod_header() {
	head -5 "$FILE_DIRECTORY/$FILE_NAME" |awk 'BEGIN{c=0} $0 ~ /LAST_MODIFIED/ {c=NR}END{print c}'
}

check_comment_header() {
	head -10 "$FILE_DIRECTORY/$FILE_NAME" |awk 'BEGIN{c=0} $0 ~ /USING*VIB/ {c=NR}END{print c}'
}

###################################################################
# check to see if the file is a script
###################################################################
check_ifis_script() {
	if [ $(echo $FILE_NAME|grep -q "\.cgi";echo $?) == 0 ]; then
		script=
		noinsert_header=1
		lastmod_line=0;
		comment_line=0;
touch /tmp/bcgi

	elif [ $(head -1 "$FILE_DIRECTORY/$FILE_NAME"|grep -q '\#\!.*bin.*[k|tc|z|c|ba]sh'; echo $? ) == 0 ] || [ $(head -1 "$FILE_DIRECTORY/$FILE_NAME"|grep -q '\#\!.*perl'; echo $? ) == 0 ] || [ $(head -1 "$FILE_DIRECTORY/$FILE_NAME"|grep -q "\#\!.*python"; echo $? ) == 0 ]; then
		script=1	
	else
		script=
		if [ -z $forcedate ]; then
			noinsert_header=1
		fi
		lastmod_line=0;
		comment_line=0;
	fi
}

###################################################################
# IF A DIRECTORY IS SUPPLIED BY MISTAKE INFORM THE USER
###################################################################
if [ -d "$FILE_DIRECTORY/$FILE_NAME" ]; then
	echo $LINE
	echo "ERROR: $FILE_DIRECTORY/$FILE_NAME is a Directory not a file"
	echo $LINE
	exit 1
fi
	
###################################################################
# CHECK FILE TYPE
###################################################################
check_valid_filetype() {
	for ftype in "block" "character"; do
		if [ $(stat -c %F "$FILE_DIRECTORY/$FILE_NAME"|grep -q $ftype ;echo $?) == 0 ]; then
			echo -e"$LINE\nERROR: $FILE_DIRECTORY/$FILE_NAME is a [$ftype] file\n$LINE"
			exit 1
		fi
	done
}
###################################################################
# Determine if the file type is of a script and should include the date/modification time
###################################################################
if [ ! -f $NOTIME ] && [ -f "$FILE_DIRECTORY/$FILE_NAME" ]; then
	lastmod_line=$(check_lastmod_header)		# check to see if the LAST_MODIFIED time is atop the file
	comment_line=$(check_comment_header)		# check to see if the optional VIB HEADER is atop the file
	check_ifis_script
fi
###################################################################
#
# check the filesize to see if it exceeds the max file size to edit and backup a file
#
###################################################################
file_not_exist() {
        writelog "No changes made. File [$FILE_DIRECTORY/$FILE_NAME] does not exist. Exiting.."
        exit 1
}
###################################################################
# Display file we are about to edit IF devtest option is given
###################################################################
if [ ! -z $devtest ]; then
	check_valid_filetype
	echo "$VI_BINARY $FILE_DIRECTORY/$FILE_NAME"
	exit
fi
###################################################################
# IF VERSION BACKUP OPTION IS USED THEN LOOK FOR IN THE FILE THE
# FIRST MATCH OF 'VERSION=' AND USE THAT VALUE 
###################################################################
if [ ! -z $backup_version ]; then
	if [ -f "$FILE_DIRECTORY/$FILE_NAME" ] && [ $NOT_NEWFILE == 0 ]; then
		check_ver=$(grep -m1 "^VERSION=" "$FILE_DIRECTORY/$FILE_NAME"|cut -d= -f2-|awk '{gsub(/[[:blank:]]/,"");print}')
		if [ ! -z "$check_ver" ]; then
			if [ $(validate_version $check_ver) == 0 ]; then
				version_line=$(grep -m1 "^VERSION=" "$FILE_DIRECTORY/$FILE_NAME" |awk 'BEGIN{c=0} $0 ~ /VERSION/ {c=NR}END{print c}')
				writelog "Backing up ${FILE_NAME} --> ${FILE_NAME}.$check_ver"
				cp -pf  "$FILE_DIRECTORY/$FILE_NAME" "$FILE_DIRECTORY/${FILE_NAME}.$check_ver"	 2>/dev/nul
			else
				writelog "Unable to Validate 'VERSION=$check_ver' for $FILE_DIRECTORY/${FILE_NAME}. Skipping"
			fi
		else
				writelog "Unable to find 'VERSION=' in $FILE_DIRECTORY/${FILE_NAME}. Skipping"
		fi
	fi	
fi	
###################################################################
# IF DIRECTORY AND FILE EXIST AND IT IS NOT A NOT_NEWFILE
###################################################################

if [ -f "$FILE_DIRECTORY/$FILE_NAME" ] && [ $NOT_NEWFILE == 0 ]; then
	check_valid_filetype
	if  [ $(statfile $FILE_DIRECTORY/$FILE_NAME size) -gt $MAX_USER_SUPPLIED_FILE_SIZE ]; then
		writelog "Unable to backup file as MAX_USER_SUPPLIED_FILE_SIZE -->$MAX_USER_SUPPLIED_FILE_SIZE"
		sleep 1
		"$VI_BINARY" "$FILE_DIRECTORY/$FILE_NAME"
		exit
	fi
fi

# IF the file does not exist (i.e. path to file) then create new file
if [ ! -f "$FILE_DIRECTORY/$FILE_NAME" ]; then
	if [[ (( -n "$2" ) && ( "$2" = "n" )) || ( $MAKE_NEW == 1 )  ]]; then
		writelog "Creating $FILE_NAME"
		"$VI_BINARY" "$FILE_DIRECTORY/$FILE_NAME"
		if [ ! -f "$FILE_DIRECTORY/$FILE_NAME" ]; then
			file_not_exist
		else
			cp -pf "$FILE_DIRECTORY/$FILE_NAME" "$BACKUP_DIRECTORY/${FILE_NAME}.${MYID}.0" > /dev/null 2>&1
			newfile=1
		fi
	else
		writelog "File not found. To create new file enter '#>vi <file> n'";
		exit;
	fi

else
	# IF the file DOES Exist AND there is no initial backup file then create a backup file
	if [ ! -f "$BACKUP_DIRECTORY/${FILE_NAME}.${MYID}.1" ] && [ -z $nobackup ]; then 
		cp -p -f "$FILE_DIRECTORY/$FILE_NAME" "$BACKUP_DIRECTORY/${FILE_NAME}.${MYID}.1" > /dev/null 2>&1
	fi

	# Copy file to TMPFILE for backup purposes
	cp -pf "$FILE_DIRECTORY/$FILE_NAME" "$TMPFILE" > /dev/null 2>&1
	
	# verify file is a valid filetype
	check_valid_filetype

	# VI Edit the file
	"$VI_BINARY" "$FILE_DIRECTORY/$FILE_NAME"

	# IF File still does not exist after editing the file then notify user
	if [ ! -f "$FILE_DIRECTORY/$FILE_NAME" ]; then
		file_not_exist
	fi
fi

###################################################################
#
# Comparing new changes to the original file
#
###################################################################
compare_files() {
	if [ $ORIGINAL_USER_SUPPLIED_FILE_SIZE == $(statfile "$FILE_DIRECTORY/$FILE_NAME" size ) ]; then
		echo 0
	else
		echo 1
	fi
}
###################################################################
compare_files_num() { 
		local e=$(statfile "$FILE_DIRECTORY/$FILE_NAME" size)
		echo $(expr $e - $ORIGINAL_USER_SUPPLIED_FILE_SIZE)
}
###################################################################
if [ ! -z $newfile ]; then
	writelog "Created new file --> $FILE_DIRECTORY/$FILE_NAME"
	vib_cleanup
	exit 0
else
	if [ $CONFIRM_CHANGES = 0 ]; then
		echo ""
		writelog "Comparing changes ..."
	fi
	if [ $(compare_files) == 0 ]; then
		if [ $CONFIRM_CHANGES = 0 ]; then
			writelog "No changes found ... "
		fi
		vib_cleanup
		exit 0
	fi
fi

#
###################################################################
#
# FUNCTION To create a backup
#
###################################################################
create_backupfile()
{
	max_files=$4
	if [  -z "$6" ]; then
		ID="$3"
	else
		ID="${3}_${6}"
	fi

	max_files=`expr $max_files - 1`
	if [ $(ls ${1}/${2}.${ID}*|wc -l 2>/dev/null ) -gt 1 ]; then
		for ((i=$max_files;i>=1;i--)); do
			num=`expr $i + 1`
			if [ -f  "${1}/${2}.${ID}.${i}" ]; then
				mv -f  "${1}/${2}.${ID}.${i}" "${1}/${2}.${ID}.${num}" >/dev/null 2>&1
				CURRENT_BACKUP_FILE="${1}/${2}.${ID}.${num}"
			fi
		done
	else
		CURRENT_BACKUP_FILE="${1}/${2}.${ID}.1"
	fi
}
###################################################################


###################################################################
#
# Roll versions of $INPUT (file being edited)
#
###################################################################
if [ "$USEDIR" -eq 1 ] && [ -z $nobackup ]; then
	create_backupfile  "$BACKUP_DIRECTORY" "$FILE_NAME" "${MYID}" "${MAX}" "$TMPFILE" 
else
	create_backupfile  "$BACKUP_DIRECTORY" "$FILE_NAME" "${MYID}" "${MAX}"  "$TMPFILE" "$TMPBACKUP_DIRECTORY"
fi
###################################################################
###################################################################
###################################################################

c=0;
if [ $PROMPT = 0 ]; then

	if [ "$2" != "n" ]; then
		if  [ $CONFIRM_CHANGES == 0 ]; then
			while [ $c != 1 ]
			do
				printf "Commit Changes [y] "
				read ans
				ans=`echo $ans |tr "[:upper:]" "[:lower:]"`
				case "$ans" in
					"y")   c=1; ;;
					"yes") c=1; ;;
					"n")   c=1; ;;
					"no")  c=1; ;;
					" ")   c=1; ans="y"; ;;
					".")   c=0; ans="y"; ;;
					",")   c=0; ans="n"; ;;
					*)    c=1; ans="y"; ;;
				esac
			done
		else

			ans="y"	
		fi

		if [ "$ans" = "y" ] || [ "$ans" = "Y" ] || [ "$ans" = "yes" ] || [ "$ans" = "" ]; then
			if [ $(compare_files) != 0 ]; then
				if  [ $BACKUP_NOTIFICATION == 0 ]; then
					
					writelog "Changes to file: [$FILE_NAME] Saved ..."
					if [ -z $nobackup ]; then
						writelog "Backup created. $CURRENT_BACKUP_FILE"
					fi
				fi
				writelog "$MYID" "$FILE_DIRECTORY/$FILE_NAME"
			fi
			vib_cleanup
			c=0
		else
			writelog "Restoring original..."
			mv -f "$TMPFILE" "$FILE_DIRECTORY/$FILE_NAME" > /dev/null 2>&1
		fi
	elif [ "$2" = "n" ]; then
		if  [ $BACKUP_NOTIFICATION == 0 ]; then
			if [ $(compare_files) != 0 ]; then
				writelog "Changes to file: [$FILE_NAME] Saved ..."
				if [ -z $nobackup ]; then
					printf "Backup File:\n$CURRENT_BACKUP_FILE\n"
				fi
			fi
		fi
		writelog "$MYID" "$FILE_DIRECTORY/$FILE_NAME"
		vib_cleanup
	fi

		 
else
	if  [ $BACKUP_NOTIFICATION == 0 ]; then
		writelog "Changes Automatically Saved ..."
		printf "Backup File:\n$CURRENT_BACKUP_FILE\n"
	fi
	writelog "$MYID" "$FILE_DIRECTORY/$FILE_NAME" 
	vib_cleanup
fi


###################################################################
# if -x option for make executable is used, then set file to chmod 744
###################################################################
if [ ! -z $make_executable ]; then
	writelog "Setting Permissions to $FILE_NAME --> 755"
	chmod 755 "$FILE_DIRECTORY/$FILE_NAME"
fi
###################################################################
# Pre-Pend the LAST_MODIFIED <date/time> at the beginning of the file
# if the file is a perl/ksh/sh/bash script 
# OR
# if the '-t' argument is supplied
###################################################################
if [ ! -f $NOTIME ]; then
	add_change_date 
fi
###################################################################
# Check the $LOGFILE size. If greater than $LOGSIZE
# then rotate the logs
###################################################################
rotatelogs

###################################################################
vib_cleanup
###################################################################
######################### END  ####################################
###################################################################
